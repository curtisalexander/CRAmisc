% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/chunked-invoke-rows.R
\name{chunked_invoke_rows}
\alias{chunked_invoke_rows}
\title{Apply a function to each row of a database result set.}
\usage{
chunked_invoke_rows(res, f, n, gc = NA_character_)
}
\arguments{
\item{res}{\code{DBI::dbSendQuery} result set.}

\item{f}{The function that will be applied to each row of the database result
set.  \code{f} is assumed to be constructed using a \code{dplyr} pipeline
where a dataframe is passed as the sole parameter and a transformed dataframe
is returned.}

\item{n}{The number of rows to pull back from the database result set for
each chunk.}

\item{gc}{The type of garbage collection to run.  Default is \code{NA} or no
garbage collection.  Choices include
\itemize{
  \item \code{r} = R garbage collection
  \item \code{j} = Java garbage collection
  \item \code{rj} = R and Java garbage collection
}}
}
\value{
A dataframe that has been transformed by \code{f}.
}
\description{
\code{chunked_invoke_rows} pulls chunks from a database result set and
applies a function to each row of the result set.  All transformed chunks
are row bound to return a single dataframe.
}
\details{
This function is useful when processing database result sets that are
extremely large.  For example, if XML docs, JSON docs, or blobs of any kind
are stored in a database column, then \code{chunked_invoke_rows} can be
used to iteratively process and transform the data.
}
\examples{
\dontrun{
# create in-memory SQLite database
dbcon <- DBI::dbConnect(RSQLite::SQLite(), dbname = ":memory:")
DBI::dbWriteTable(dbcon, "mtcars", mtcars)

# create and send a query
sql_query <- "SELECT * FROM mtcars where hp > 120"
res <- DBI::dbSendQuery(dbcon, sql_query)

# create a function to operate on chunks
# the function should accept a dataframe and return a dataframe
f <- function(df) {
  df \%>\%
    dplyr::mutate(hp_to_cyl = hp / cyl) \%>\%
    dplyr::arrange(hp_to_cyl)
}

# process 5 rows at a time
mtcars_new <- chunked_invoke_rows(res, f, 5)

# cleanup
DBI::dbClearResult(res)
DBI::dbDisconnect(dbcon)
}

}
\seealso{
\itemize{
  \item \code{\link[purrr]{invoke_rows}}
  \item \code{\link[dplyr]{rowwise}}
  \item The \href{https://github.com/edwindj/chunked}{chunked} package.
}
}

